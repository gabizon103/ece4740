// VerilogA for ece4740, lab4_sram_test_gen, veriloga

`include "constants.vams"
`include "disciplines.vams"

module lab4_sram_test_gen(ADDR, DATA, WE);

// Declare outputs
output WE;

output[5:0] ADDR;
output[7:0] DATA;

voltage WE;
voltage[5:0] ADDR;
voltage[7:0] DATA;

// Declare locally-scoped constants using localparam keyword
// Clock period for test cases
localparam cp = 4000p;

// Number of testcases per testsuite
localparam tb1 = 128;

integer tb1Count = 0;
integer addrCount = 0;
integer writeAA = 1;

// Constants for clock periods
parameter real	clk_period = cp from (0:inf);
parameter real	trise = 20p from [0:inf];
parameter real	tfall = 20p from [0:inf];

// Constants for voltage signal bounds
parameter real	v_high = 1.2;
parameter real	v_low = 0.0;

// Initialize integer variables for signal generator outputs
integer 		ADDR_curr;
integer 		DATA_curr;
integer 		WE_curr;

// Keeps track of how many testcases have completed
integer			curTestCount = 0;

genvar			j;

analog begin

    @(initial_step) begin
        ADDR_curr = 0;
        DATA_curr = 0;
        WE_curr = 0;
    end

/*
 	-------------------------------------------------
				TESTCASE DEFINITIONS
	-------------------------------------------------
*/

    // Timer block to run testcases
    @(timer(0.5n,clk_period)) begin
        case (curTestCount)
            0: begin DATA_curr = 8'hAA; WE_curr = 1; ADDR_curr = 1; end
            1: begin ADDR_curr = 1; end
            2: begin DATA_curr = 8'h55; WE_curr = 1; ADDR_curr = 2; end
            3: begin ADDR_curr = 2; end
            4: begin DATA_curr = 8'h55; WE_curr = 0; ADDR_curr = 1; end
            5: begin ADDR_curr = 1; END
            6: begin DATA_curr = 8'h55; WE_curr = 0; ADDR_curr = 2; end
            7: begin ADDR_curr = 2; end
            
        endcase
        curTestCount = curTestCount + 1;
        // if (addrCount == 63) begin addrCount = 0; end

        // if (curTestCount < 128) begin
        //     if ((curTestCount & 1) == 1) begin
        //         ADDR_curr = addrCount;
        //         addrCount = addrCount+1;
        //     end else begin
        //     if (((curTestCount >> 1) & 1) == 1) begin
        //         ADDR_curr = 0;
        //         DATA_curr = 8'h55;
        //         WE_curr = 1;
        //     end else begin
        //         ADDR_curr = 0;
        //         DATA_curr = 8'hAA;
        //         WE_curr = 1;
        //     end
        // end

        // end else if (curTestCount >= 128 && curTestCount < 256) begin
        //     WE_curr = 0;
        //     if ((curTestCount & 1) == 1) begin
        //         ADDR_curr = addrCount;
        //         addrCount = addrCount+1;
        //     end else begin
        //     if ((((curTestCount) >> 1) & 1) == 1) begin
        //         ADDR_curr = 0;
        //         WE_curr = 0;
        //     end else begin
        //         ADDR_curr = 0;
        //         WE_curr = 0;
        //     end
        // end
        // end
        // curTestCount = curTestCount + 1;
    end


    // Parse integer case inputs into binary and assert them
    for (j = 0; j < 8; j = j + 1) begin
		V(DATA[j]) <+ transition(DATA_curr & (1 << j) ? v_high : v_low, 0, trise, tfall);
	end
    
    for (j = 0; j < 6; j = j + 1) begin
		V(ADDR[j]) <+ transition(ADDR_curr & (1 << j) ? v_high : v_low, 0, trise, tfall);
	end

	V(WE) <+ transition(WE_curr ? v_high : v_low, 0, trise, tfall);

end

endmodule
